<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Let&#39;s build a virtual machine: Part 2 - The main loop and assembler</title>
	
	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu|Lora">
	<link rel="stylesheet" href="/css/style.css">
	
</head>
<body>
	<header class="wrapper">
    <nav>
        <a href="https://badlydrawnrod.github.io/">Home</a>
        <ul>
			
            
            <li><a href="/page/about/">About</a></li>
            
            <li><a href="/posts/">All posts</a></li>
            
        </ul>
    </nav>
    
</header>
	
<main class="wrapper">
    <article>
        <p></p>
        
        <div class="date">7 April, 2024</div>
        
        <div>
            <p>Implementing just enough of the Owl-2820 CPU to run Fibonacci.</p>
<h1 id="part-2-implementing-the-main-loop-and-an-assembler">Part 2 Implementing the main loop and an assembler</h1>
<p>In <a href="https://badlydrawnrod.github.io/posts/2024/03/17/lbavm-000-intro/">Part 0</a> of this series, we looked at a C implementation of the Fibonacci sequence compiled to RISC-V assembly language and saw that it only used nine opcodes.</p>
<p>In <a href="https://badlydrawnrod.github.io/posts/2024/04/02/lbavm-001/">Part 1</a> we were introduced to the Owl-2820 CPU. We saw how it implements registers, how it represents instructions in memory, and how each individual opcode is implemented.</p>
<p>By now we&rsquo;ve learned:</p>
<ul>
<li>what the Fibonacci sequence looks like when compiled to assembly language</li>
<li>how to represent the Owl-2820 CPU&rsquo;s registers in code</li>
<li>how to encode and decode Owl instructions into opcodes and operands</li>
<li>how to implement the nine opcodes required to implement the Fibonacci sequence</li>
</ul>
<p>Now we&rsquo;re going to put it all together and implement a main loop that will read instructions from memory, decode them into an opcode and its operands, then execute them.</p>
<p>We will also implement a mini assembler so that we can write code for the Owl CPU to execute.</p>
<h1 id="the-main-loop">The main loop</h1>
<p>When a CPU fetches an instruction from memory, it reads it from the address pointed to by the program counter, then it decodes it and executes it. When it has finished executing the instruction then it sets the program counter to the address of the next instruction, and continues.</p>
<p>In our initial implementation of the Owl CPU, we&rsquo;re going to have it stop when it reaches an illegal instruction. Later, we&rsquo;ll expand the code so that it&rsquo;ll stop for other reasons, for example, after it has run a given number of instructions.</p>
<p>By the end of this post, we&rsquo;ll have implemented an Owl CPU that can read Owl instructions from memory, decode the nine opcodes required to implement Fibonacci, and execute them.</p>
<p>Implementing only nine opcodes may not seem like much, but as we will expand on this over the course of this series, it will be worth taking your time to understand how it works.</p>
<p>However, if you&rsquo;re pressed for time, then you can see the entire program and its output on <a href="https://godbolt.org/z/Y5cKaK85e">Compiler Explorer</a>.</p>
<h2 id="main-loop---outline">Main loop - outline</h2>
<p>We can write the main loop as a <code>Run()</code> function that contains a <code>while</code>-loop that terminates when it hits an illegal instruction.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">bool</span> done = false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (!done)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Fetch a 32-bit word from memory at the address pointed to by the program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Decode the word to extract the opcode.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Dispatch it and execute it.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Stop the loop if we hit an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>code</code> parameter represents a view of memory as an array of 32-bit words. Memory in Owl is byte-addressable, but for simplicity, we&rsquo;re going to represent memory that contains code as word-addressable.</p>
<h2 id="fetching">Fetching</h2>
<p>We need a representation of the program counter, <em>pc</em>. This register is typically incremented after each instruction to go to the next instruction, but some instructions such as <code>beq</code>, <code>bltu</code>, <code>call</code> and <code>j</code> can set it to another value. To accommodate this, we&rsquo;ll use another 32-bit value, <em>nextPc</em>, to represent the address that <em>pc</em> will be set to at the start of each instruction.</p>
<p>When our Owl CPU goes to fetch another instruction from memory, it first copies the value in <em>nextPc</em> into <em>pc</em> then immediately updates <em>nextPc</em> to point to the next instruction. This value will be used next time around the loop, unless it is modified by an instruction such as a conditional branch, a call, or a jump. This implementation  means that <em>pc</em> is only ever updated at the start of the loop, so that its value can be used by any instructions that need to read it.</p>
<p>After implementing fetch, <code>Run()</code> looks like this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set pc and nextPc to their initial values.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> pc = 0;     <span style="color:#008000">// The program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> nextPc = 0; <span style="color:#008000">// The address of the next instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">bool</span> done = false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (!done)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Fetch a 32-bit word from memory at the address pointed to by the program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        pc = nextPc;
</span></span><span style="display:flex;"><span>        nextPc += wordSize;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins = code[pc / wordSize];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Decode the word to extract the opcode.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Dispatch it and execute it.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Stop the loop if we hit an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We&rsquo;ve declared <code>pc</code> and <code>nextPc</code>, and added the code to fetch a 32-bit word from memory. As <code>nextPc</code> represents a register which points to byte-addressable memory, and <code>code</code> is addressed by 32-bit words, we have to increment <code>nextPc</code> by the word size. Likewise, we need to divide <code>pc</code> by the word size when reading from <code>code</code>.</p>
<h2 id="decoding-and-dispatching">Decoding and dispatching</h2>
<p>Once the word containing the instruction has been fetched from memory, we need to decode it, then dispatch it to an instruction handler for the opcode.</p>
<p>The very first part of this is to extract the opcode which, as we saw in <a href="https://badlydrawnrod.github.io/posts/2024/04/02/lbavm-001/">Part 1</a>, is a simple operation.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    Opcode opcode = Opcode(ins &amp; 0x7f);
</span></span></code></pre></div><p>We can use a <code>switch</code> statement to dispatch on the opcode to an instruction handler. Each instruction handler will decode the operands required by the opcode, then perform a simple opcode-specific operation on them, for example, adding them together.</p>
<p>After adding the code to decode and dispatch, <code>Run()</code> looks like this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set pc and nextPc to their initial values.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> pc = 0;     <span style="color:#008000">// The program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> nextPc = 0; <span style="color:#008000">// The address of the next instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">bool</span> done = false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (!done)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Fetch a 32-bit word from memory at the address pointed to by the program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        pc = nextPc;
</span></span><span style="display:flex;"><span>        nextPc += wordSize;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins = code[pc / wordSize];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Decode the word to extract the opcode.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> Opcode opcode = Opcode(ins &amp; 0x7f);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Dispatch it and execute it.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">switch</span> (opcode)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Add:
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Implement add.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;            
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Addi
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Implement addi.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;            
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// ... etc
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Stop the loop if we hit an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// If we don&#39;t recognise the opcode then by default we have an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            done = true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="registers">Registers</h2>
<p>We saw in <a href="https://badlydrawnrod.github.io/posts/2024/04/02/lbavm-001/">Part 1</a> that many of the instructions operate on Owl&rsquo;s integer registers and that we can represent registers with a C-style array.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> x[32] = {}; <span style="color:#008000">// The integer registers.
</span></span></span></code></pre></div><p>Let&rsquo;s introduce them before the start of the loop.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set pc and nextPc to their initial values.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> pc = 0;     <span style="color:#008000">// The program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> nextPc = 0; <span style="color:#008000">// The address of the next instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set all the integer registers to zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> x[32] = {}; <span style="color:#008000">// The integer registers.
</span></span></span></code></pre></div><h2 id="instructions">Instructions</h2>
<p>Implementing each instruction is straightforward. We already know how to decode the operands, and we saw in <a href="https://badlydrawnrod.github.io/posts/2024/04/02/lbavm-001/">Part 1</a> how each instruction is implemented.</p>
<p>To illustrate just how straightforward, here is the handler for <code>add</code> in its entirety. It decodes the operands <em>r0</em>, <em>r1</em>, and <em>r2</em>, then it uses them as indexes into the <em>x</em>-registers array, adding <em>x[r1]</em> to <em>x[r2]</em>, then storing the result in <em>x[r0]</em>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Add: {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Implement `Add`.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> r0 = (ins &gt;&gt; 7) &amp; 0x1f;  <span style="color:#008000">// Decode r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> r1 = (ins &gt;&gt; 12) &amp; 0x1f; <span style="color:#008000">// Decode r1.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> r2 = (ins &gt;&gt; 17) &amp; 0x1f; <span style="color:#008000">// Decode r2.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[r0] = x[r1] + x[r2];                  <span style="color:#008000">// Add the two registers.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[0] = 0;                               <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Handlers for other opcodes are similar. For example, here&rsquo;s the code to implement <code>mv</code>, which copies the value in register <em>r1</em> into register <em>r0</em>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Mv: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> r0 = (ins &gt;&gt; 7) &amp; 0x1f;  <span style="color:#008000">// Decode r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> r1 = (ins &gt;&gt; 12) &amp; 0x1f; <span style="color:#008000">// Decode r1.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[r0] = x[r1];                          <span style="color:#008000">// Copy r1 into r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[0] = 0;                               <span style="color:#008000">// Ensure x0 is always zero. 
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>And here&rsquo;s the code for <code>lui</code>, which loads a 20-bit immediate value into the upper bits of register <em>r0</em>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Lui: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> r0 = (ins &gt;&gt; 7) &amp; 0x1f;    <span style="color:#008000">// Decode r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> uimm20 = ins &amp; 0xfffff000; <span style="color:#008000">// Decode uimm20;                                  
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[r0] = uimm20;                           <span style="color:#008000">// Load uimm20 into r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[0] = 0;                                 <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="decoding-operands">Decoding operands</h2>
<p>After only three opcodes, you can probably see that there&rsquo;s a lot of unnecessary, error-prone repetition. We&rsquo;ve seen the code to extract operand <code>r0</code> three times already.</p>
<p>For the most part, the other instructions are also handled by following the pattern of decoding the same handful of operands before executing the instruction. There is so much similarity that it&rsquo;s worth taking a few minutes to extract the task of decoding operands into short functions - one per operand -  that the compiler will inline.</p>
<p>I&rsquo;ve put these functions into the <code>decode</code> namespace.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">namespace</span> decode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r0(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (ins &gt;&gt; 7) &amp; 0x1f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r1(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (ins &gt;&gt; 12) &amp; 0x1f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r2(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (ins &gt;&gt; 17) &amp; 0x1f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> imm12(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(<span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">int32_t</span>&gt;(ins &amp; 0xfff00000) &gt;&gt; 20);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs12(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(<span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">int32_t</span>&gt;(ins &amp; 0xfff00000) &gt;&gt; 19);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs20(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(<span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">int32_t</span>&gt;(ins &amp; 0xfffff000) &gt;&gt; 11);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> uimm20(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> ins &amp; 0xfffff000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We&rsquo;ll bring in the <code>decode</code> namespace at the top of <code>Run()</code> so that we don&rsquo;t have to prefix calls to these functions with <code>decode</code>. This lets us write things like <code>r0(ins)</code> instead of <code>decode::r0(ins)</code> throughout <code>Run()</code>&rsquo;s body.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">using</span> <span style="color:#00f">namespace</span> decode;
</span></span></code></pre></div><h2 id="refactored-instructions">Refactored instructions</h2>
<p>After refactoring to use the new <code>decode</code> functions, the handler for <code>add</code> simplifies to this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Add: {
</span></span><span style="display:flex;"><span>        x[r0(ins)] = x[r1(ins)] + x[r2(ins)];  <span style="color:#008000">// Add the two registers.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[0] = 0;                              <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Similarly, here&rsquo;s <code>mv</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Mv: {
</span></span><span style="display:flex;"><span>        x[r0(ins)] = x[r1(ins)]; <span style="color:#008000">// Copy r1 into r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[0] = 0;                <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>And here&rsquo;s <code>lui</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Lui: {
</span></span><span style="display:flex;"><span>        x[r0(ins)] = uimm20(ins); <span style="color:#008000">// Load uimm20 into r0.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        x[0] = 0;                 <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Most of the other instructions are very similar, so in theory we can now easily implement the rest of the main loop.</p>
<h2 id="implementing-printf">Implementing printf()</h2>
<p>However, there is a big gotcha. Our implementation of Fibonacci from <a href="https://badlydrawnrod.github.io/posts/2024/03/17/lbavm-000-intro/">Part 0</a> involved a call to <code>printf()</code>. That calls into a subroutine that we haven&rsquo;t seen yet. Clearly implementing <code>printf()</code> in Owl machine code that runs on the Owl VM will need implementations for more than the nine opcodes that we&rsquo;ve seen so far.</p>
<p>To keep things simple at this stage, I&rsquo;m going to propose that we cheat, and take advantage of the fact that as there&rsquo;s only one <code>call</code> instruction, we can temporarily hard-code it to do a <code>printf()</code>.</p>
<p>Here&rsquo;s that implementation of <code>call</code>. It has nothing to do with calling a subroutine, but instead uses the values in the two argument registers <em>a1</em> and <em>a2</em> as arguments to <code>std::format</code> as shown below.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">case</span> Opcode::Call: {
</span></span><span style="display:flex;"><span>        std::cout &lt;&lt; std::format(<span style="color:#a31515">&#34;fib({}) = {}</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, x[a1], x[a2]);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="tradeoffs">Tradeoffs</h3>
<p>This may seem somewhat specialized, but surprisingly this isn&rsquo;t without precedent. Some old computers had unusually specialized instruction sets. For example, this British computer, <a href="https://www.emidec.org.uk/emih0hom.htm">the EMIDEC</a>, had an instruction set that included <a href="https://www.emidec.org.uk/emihinst.htm">pounds sterling input and output</a>. Bear in mind that this was from the 1960s when there were <a href="https://en.wikipedia.org/wiki/%C2%A3sd">twenty shillings in a pound and twelve pence in a shilling</a> and you can get an idea just how specialized this machine was.</p>
<p>There are tradeoffs between specialized and general purpose instructions. A specialized instruction set is tempting, but I suspect that the EMIDEC probably became somewhat useless after 1971 when Britain switched to a decimal pound.</p>
<p>On the other hand, I feel that a temporary hack to implement <code>printf()</code> is a tradeoff that I&rsquo;m willing to make.</p>
<h2 id="run">Run()</h2>
<p>Our final implementation of <code>Run()</code> looks like this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">using</span> <span style="color:#00f">namespace</span> decode;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set pc and nextPc to their initial values.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> pc = 0;     <span style="color:#008000">// The program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> nextPc = 0; <span style="color:#008000">// The address of the next instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set all the integer registers to zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> x[32] = {}; <span style="color:#008000">// The integer registers.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">constexpr</span> <span style="color:#2b91af">uint32_t</span> wordSize = <span style="color:#00f">sizeof</span>(<span style="color:#2b91af">uint32_t</span>);    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">bool</span> done = false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (!done)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Fetch a 32-bit word from memory at the address pointed to by the program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        pc = nextPc;
</span></span><span style="display:flex;"><span>        nextPc += wordSize;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins = code[pc / wordSize];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Decode the word to extract the opcode.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> Opcode opcode = Opcode(ins &amp; 0x7f);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Dispatch it and execute it.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">switch</span> (opcode)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Add: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = x[r1(ins)] + x[r2(ins)]; <span style="color:#008000">// Add the two registers.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            x[0] = 0;                             <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Addi: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = x[r1(ins)] + imm12(ins); <span style="color:#008000">// Perform the addition.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            x[0] = 0;                             <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Beq: {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Perform the comparison.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">if</span> (x[r0(ins)] == x[r1(ins)])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                nextPc = pc + offs12(ins); <span style="color:#008000">// Take the branch.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Bltu: {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Perform the comparison.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">if</span> (x[r0(ins)] &lt; x[r1(ins)])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                nextPc = pc + offs12(ins); <span style="color:#008000">// Take the branch.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Call: {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Do a hard-coded printf().
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            std::cout &lt;&lt; std::format(<span style="color:#a31515">&#34;fib({}) = {}</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, x[a1], x[a2]);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::J: {
</span></span><span style="display:flex;"><span>            nextPc = pc + offs20(ins); <span style="color:#008000">// Branch.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Li: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = imm12(ins);
</span></span><span style="display:flex;"><span>            x[0] = 0; <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Lui: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = uimm20(ins);
</span></span><span style="display:flex;"><span>            x[0] = 0; <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Mv: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = x[r1(ins)];
</span></span><span style="display:flex;"><span>            x[0] = 0; <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Stop the loop if we hit an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// If we don&#39;t recognise the opcode then by default we have an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            done = true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="an-assembler">An assembler</h1>
<p>If you cast your mind back to <a href="https://badlydrawnrod.github.io/posts/2024/03/17/lbavm-000-intro/">Part 0</a>, you may remember that the RISC-V assembly language for the Fibonacci program looked like this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>        li      s0, 0                       <span style="color:#008000">; i = 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        li      s2, 2                       <span style="color:#008000">; s2 = 2
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        lui     a0, %hi(format_str)
</span></span><span style="display:flex;"><span>        addi    s1, a0, %lo(format_str)     <span style="color:#008000">; s1 = the address of the printf format string
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        li      s3, 48                      <span style="color:#008000">; s3 = 48
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        li      s4, 1                       <span style="color:#008000">; s4 = 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        j       fib                         <span style="color:#008000">; go to fib
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>print_loop:
</span></span><span style="display:flex;"><span>        mv      a0, s1                      <span style="color:#008000">; arg0 = the address of the printf format string
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        mv      a1, s0                      <span style="color:#008000">; arg1 = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>                                            <span style="color:#008000">; arg2 is already set to current
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        call    printf                      <span style="color:#008000">; call printf
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        addi    s0, s0, 1                   <span style="color:#008000">; i = i + 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        beq     s0, s3, done                <span style="color:#008000">; if i == 48 go to done
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>fib:
</span></span><span style="display:flex;"><span>        mv      a2, s0                      <span style="color:#008000">; current = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        bltu    s0, s2, print_loop          <span style="color:#008000">; if i &lt; 2 go to print_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        li      a0, 0                       <span style="color:#008000">; previous = 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        li      a2, 1                       <span style="color:#008000">; current = 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        mv      a1, s0                      <span style="color:#008000">; n = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>fib_loop:
</span></span><span style="display:flex;"><span>        mv      a3, a2                      <span style="color:#008000">; tmp = current
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        addi    a1, a1, -1                  <span style="color:#008000">; n = n - 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        add     a2, a0, a2                  <span style="color:#008000">; current = current + prev
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        mv      a0, a3                      <span style="color:#008000">; previous = tmp
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        bltu    s4, a1, fib_loop            <span style="color:#008000">; if n &gt; 1 go to fib_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        j       print_loop                  <span style="color:#008000">; go to print_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>done:
</span></span><span style="display:flex;"><span>        li      a0, 0                       <span style="color:#008000">; set the return value of main() to 0
</span></span></span></code></pre></div><p>We need to convert this from text into instructions that will be understood by the Owl-2820 CPU. That sounds like the job for an <a href="https://en.wikipedia.org/wiki/Assembly_languag">assembler</a>.</p>
<p>Rather than going the whole hog and writing a full-blown assembler, we can create a simple <code>Assembler</code> class whose member functions are named after opcodes. Each of these member functions will encode the corresponding opcode and its operands into a instruction, then emit the instruction as Owl-2820 machine code.</p>
<p>That would allow us to write the assembly language program in C++ like this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    Assembler a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// main:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s0, 0);                <span style="color:#008000">// li   s0, 0                   ; i = 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s2, 2);                <span style="color:#008000">// li   s2, 2                   ; s2 = 2
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Lui(a0, 1);               <span style="color:#008000">// lui  a0, %hi(format_str)
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Addi(s1, a0, -548);       <span style="color:#008000">// addi s1, a0, %lo(format_str) ; s1 = the address of the printf format string
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s3, 48);               <span style="color:#008000">// li   s3, 48                  ; s3 = 48
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s4, 1);                <span style="color:#008000">// li   s4, 1                   ; s4 = 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.J(fib);                   <span style="color:#008000">// j    fib                     ; go to fib
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// print_loop:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a0, s1);               <span style="color:#008000">// mv   a0, s1                  ; arg0 = the address of the printf format string
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a1, s0);               <span style="color:#008000">// mv   a1, s0                  ; arg1 = i (arg2 contains current)
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Call(printf);             <span style="color:#008000">// call printf                  ; call printf
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Addi(s0, s0, 1);          <span style="color:#008000">// addi s0, s0, 1               ; i = i + 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Beq(s0, s3, done);        <span style="color:#008000">// beq  s0, s3, done            ; if i == 48 go to done
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// fib:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a2, s0);               <span style="color:#008000">// mv   a2, s0                  ; current = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Bltu(s0, s2, print_loop1);<span style="color:#008000">// bltu s0, s2, print_loop      ; if i &lt; 2 go to print_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(a0, 0);                <span style="color:#008000">// li   a0, 0                   ; previous = 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(a2, 1);                <span style="color:#008000">// li   a2, 1                   ; current = 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a1, s0);               <span style="color:#008000">// mv   a1, s0                  ; n = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// fib_loop:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a3, a2);               <span style="color:#008000">// mv   a3, a2                  ; tmp = current
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Addi(a1, a1, -1);         <span style="color:#008000">// addi a1, a1, -1              ; n = n - 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Add(a2, a0, a2);          <span style="color:#008000">// add  a2, a0, a2              ; current = current + prev
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a0, a3);               <span style="color:#008000">// mv   a0, a3                  ; previous = tmp
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Bltu(s4, a1, fib_loop);   <span style="color:#008000">// bltu s4, a1, fib_loop        ; if n &gt; 1 go to fib_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.J(print_loop2);           <span style="color:#008000">// j    print_loop              ; go to print_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// done:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(a0, 0);                <span style="color:#008000">// li   a0, 0                   ; set the return value of main() to 0
</span></span></span></code></pre></div><p>This uses the <code>Assembler</code> class to encode one instruction at a time.</p>
<h2 id="encoding-instructions">Encoding instructions</h2>
<p>In the <code>Assembler</code> class, each opcode is represented by a member function that encodes it along with its operands. The individually encoded components are then combined by ORing them together before the resulting instruction is emitted as code.</p>
<p>Here&rsquo;s the code that encodes each instruction. I&rsquo;ll explain the <code>encode::</code> functions and <code>Emit()</code> a little later.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Add(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">uint32_t</span> r2)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// add r0, r1, r2
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Add) | encode::r0(r0) | encode::r1(r1) | encode::r2(r2));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Addi(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">int32_t</span> imm12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// addi r0, r1, imm12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Addi) | encode::r0(r0) | encode::r1(r1) | encode::imm12(imm12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Beq(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">int32_t</span> offs12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// beq r0, r1, offs12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Beq) | encode::r0(r0) | encode::r1(r1) | encode::offs12(offs12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Bltu(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">int32_t</span> offs12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// bltu r0, r1, offs12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Bltu) | encode::r0(r0) | encode::r1(r1) | encode::offs12(offs12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Call(<span style="color:#2b91af">int32_t</span> offs20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// call offs20
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Call) | encode::offs20(offs20));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> J(<span style="color:#2b91af">int32_t</span> offs20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// j offs20
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::J) | encode::offs20(offs20));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Li(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">int32_t</span> imm12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// li r0, imm12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Li) | encode::r0(r0) | encode::imm12(imm12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Lui(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> uimm20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// lui r0, uimm20
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Lui) | encode::r0(r0) | encode::uimm20(uimm20));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Mv(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// mv r0, r1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Mv) | encode::r0(r0) | encode::r1(r1));
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="encoding-opcodes-and-operands">Encoding opcodes and operands</h2>
<p>The opcode and operands are encoded by standalone functions in the <code>encode</code> namespace. Each of these functions encodes its namesake, so <code>opc()</code> encodes an opcode, <code>r0()</code> encodes register <em>r0</em>, and so on.</p>
<p>Encoding operands is the inverse of decoding them, so there&rsquo;s not much to explain here.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">namespace</span> encode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> opc(Opcode opcode)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#2b91af">uint32_t</span>(opcode);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r0(<span style="color:#2b91af">uint32_t</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (r &amp; 0x1f) &lt;&lt; 7;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r1(<span style="color:#2b91af">uint32_t</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (r &amp; 0x1f) &lt;&lt; 12;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r2(<span style="color:#2b91af">uint32_t</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (r &amp; 0x1f) &lt;&lt; 17;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> imm12(<span style="color:#2b91af">int32_t</span> imm12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(imm12 &lt;&lt; 20);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs12(<span style="color:#2b91af">int32_t</span> offs12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Assumes that offs12 is pre-multiplied to a byte offset.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(offs12 &lt;&lt; 19) &amp; 0xfff00000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs20(<span style="color:#2b91af">int32_t</span> offs20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Assumes that offs20 is pre-multiplied to a byte offset.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(offs20 &lt;&lt; 11) &amp; 0xfffff000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> uimm20(<span style="color:#2b91af">uint32_t</span> uimm20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (uimm20 &lt;&lt; 12) &amp; 0xfffff000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="emitting-code">Emitting code</h2>
<p>The <code>Emit()</code> member function pushes a <code>uint32_t</code> representing an encoded instruction, onto the end of a vector representing the code.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">private</span>:
</span></span><span style="display:flex;"><span>    std::vector&lt;<span style="color:#2b91af">uint32_t</span>&gt; code_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span>:    
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Emit(<span style="color:#2b91af">uint32_t</span> u)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        code_.push_back(u);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The assembled Owl-2820 machine code is accessed with the <code>Code()</code> member function.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#00f">const</span> std::vector&lt;<span style="color:#2b91af">uint32_t</span>&gt;&amp; Code() <span style="color:#00f">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> code_;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h1 id="running-the-fibonacci-sequence-on-the-owl-2820-cpu">Running the Fibonacci sequence on the Owl-2820 CPU</h1>
<p>Here&rsquo;s the end result. In a little more than 300 lines of C++ we&rsquo;ve implemented a simple assembler that assembles the Fibonacci program into Owl-2820 machine code, and an emulator that runs that machine code on an emulated Owl-2820 CPU.</p>
<p>You can see the results of running this on <a href="https://godbolt.org/z/Y5cKaK85e">Compiler Explorer</a>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;cstdint&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;format&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;iostream&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;string&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;vector&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// Symbolic register names.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#00f">enum</span> { zero, ra, sp, gp, tp, t0, t1, t2, s0, s1, a0, a1, a2, a3, a4, a5, a6, a7,
</span></span><span style="display:flex;"><span>       s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, t3, t4, t5, t6 };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// Opcodes.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span><span style="color:#00f">enum</span> <span style="color:#00f">class</span> <span style="color:#2b91af">Opcode</span> : <span style="color:#2b91af">uint32_t</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Illegal = 0,
</span></span><span style="display:flex;"><span>    Add,
</span></span><span style="display:flex;"><span>    Addi,
</span></span><span style="display:flex;"><span>    Beq,
</span></span><span style="display:flex;"><span>    Bltu,
</span></span><span style="display:flex;"><span>    Call,
</span></span><span style="display:flex;"><span>    J,
</span></span><span style="display:flex;"><span>    Li,
</span></span><span style="display:flex;"><span>    Lui,
</span></span><span style="display:flex;"><span>    Mv
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">namespace</span> decode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r0(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (ins &gt;&gt; 7) &amp; 0x1f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r1(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (ins &gt;&gt; 12) &amp; 0x1f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r2(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (ins &gt;&gt; 17) &amp; 0x1f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> imm12(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(<span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">int32_t</span>&gt;(ins &amp; 0xfff00000) &gt;&gt; 20);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs12(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(<span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">int32_t</span>&gt;(ins &amp; 0xfff00000) &gt;&gt; 19);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs20(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(<span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">int32_t</span>&gt;(ins &amp; 0xfffff000) &gt;&gt; 11);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> uimm20(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> ins &amp; 0xfffff000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">void</span> Run(<span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span>* code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">using</span> <span style="color:#00f">namespace</span> decode;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set pc and nextPc to their initial values.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> pc = 0;     <span style="color:#008000">// The program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> nextPc = 0; <span style="color:#008000">// The address of the next instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Set all the integer registers to zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">uint32_t</span> x[32] = {}; <span style="color:#008000">// The integer registers.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">constexpr</span> <span style="color:#2b91af">uint32_t</span> wordSize = <span style="color:#00f">sizeof</span>(<span style="color:#2b91af">uint32_t</span>);    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">bool</span> done = false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (!done)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Fetch a 32-bit word from memory at the address pointed to by the program counter.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        pc = nextPc;
</span></span><span style="display:flex;"><span>        nextPc += wordSize;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> <span style="color:#2b91af">uint32_t</span> ins = code[pc / wordSize];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Decode the word to extract the opcode.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">const</span> Opcode opcode = Opcode(ins &amp; 0x7f);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Dispatch it and execute it.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">switch</span> (opcode)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Add: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = x[r1(ins)] + x[r2(ins)];  <span style="color:#008000">// Add the two registers.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            x[0] = 0;                              <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Addi: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = x[r1(ins)] + imm12(ins); <span style="color:#008000">// Perform the addition.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            x[0] = 0;                             <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Beq: {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Perform the comparison.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">if</span> (x[r0(ins)] == x[r1(ins)])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                nextPc = pc + offs12(ins); <span style="color:#008000">// Take the branch.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Bltu: {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Perform the comparison.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">if</span> (x[r0(ins)] &lt; x[r1(ins)])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                nextPc = pc + offs12(ins); <span style="color:#008000">// Take the branch.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Call: {
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// Do a hard-coded printf().
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            std::cout &lt;&lt; std::format(<span style="color:#a31515">&#34;fib({}) = {}</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, x[a1], x[a2]);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::J: {
</span></span><span style="display:flex;"><span>            nextPc = pc + offs20(ins); <span style="color:#008000">// Branch.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Li: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = imm12(ins);
</span></span><span style="display:flex;"><span>            x[0] = 0; <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Lui: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = uimm20(ins);
</span></span><span style="display:flex;"><span>            x[0] = 0; <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> Opcode::Mv: {
</span></span><span style="display:flex;"><span>            x[r0(ins)] = x[r1(ins)];
</span></span><span style="display:flex;"><span>            x[0] = 0; <span style="color:#008000">// Ensure x0 is always zero.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Stop the loop if we hit an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#008000">// If we don&#39;t recognise the opcode then by default we have an illegal instruction.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>            done = true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">namespace</span> encode
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> opc(Opcode opcode)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#2b91af">uint32_t</span>(opcode);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r0(<span style="color:#2b91af">uint32_t</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (r &amp; 0x1f) &lt;&lt; 7;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r1(<span style="color:#2b91af">uint32_t</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (r &amp; 0x1f) &lt;&lt; 12;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> r2(<span style="color:#2b91af">uint32_t</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (r &amp; 0x1f) &lt;&lt; 17;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> imm12(<span style="color:#2b91af">int32_t</span> imm12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(imm12 &lt;&lt; 20);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs12(<span style="color:#2b91af">int32_t</span> offs12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Assumes that offs12 is pre-multiplied to a byte offset.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(offs12 &lt;&lt; 19) &amp; 0xfff00000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> offs20(<span style="color:#2b91af">int32_t</span> offs20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// Assumes that offs20 is pre-multiplied to a byte offset.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#00f">return</span> <span style="color:#00f">static_cast</span>&lt;<span style="color:#2b91af">uint32_t</span>&gt;(offs20 &lt;&lt; 11) &amp; 0xfffff000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">uint32_t</span> uimm20(<span style="color:#2b91af">uint32_t</span> uimm20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (uimm20 &lt;&lt; 12) &amp; 0xfffff000;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">Assembler</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::vector&lt;<span style="color:#2b91af">uint32_t</span>&gt; code_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> std::vector&lt;<span style="color:#2b91af">uint32_t</span>&gt;&amp; Code() <span style="color:#00f">const</span> { <span style="color:#00f">return</span> code_; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Emit(<span style="color:#2b91af">uint32_t</span> u)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        code_.push_back(u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Add(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">uint32_t</span> r2)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// add r0, r1, r2
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Add) | encode::r0(r0) | encode::r1(r1) | encode::r2(r2));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Addi(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">int32_t</span> imm12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// addi r0, r1, imm12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Addi) | encode::r0(r0) | encode::r1(r1) | encode::imm12(imm12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Beq(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">int32_t</span> offs12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// beq r0, r1, offs12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Beq) | encode::r0(r0) | encode::r1(r1) | encode::offs12(offs12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Bltu(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1, <span style="color:#2b91af">int32_t</span> offs12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// bltu r0, r1, offs12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Bltu) | encode::r0(r0) | encode::r1(r1) | encode::offs12(offs12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Call(<span style="color:#2b91af">int32_t</span> offs20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// call offs20
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Call) | encode::offs20(offs20));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> J(<span style="color:#2b91af">int32_t</span> offs20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// j offs20
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::J) | encode::offs20(offs20));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Li(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">int32_t</span> imm12)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// li r0, imm12
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Li) | encode::r0(r0) | encode::imm12(imm12));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Lui(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> uimm20)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// lui r0, uimm20
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Lui) | encode::r0(r0) | encode::uimm20(uimm20));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">void</span> Mv(<span style="color:#2b91af">uint32_t</span> r0, <span style="color:#2b91af">uint32_t</span> r1)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// mv r0, r1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        Emit(encode::opc(Opcode::Mv) | encode::r0(r0) | encode::r1(r1));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std::vector&lt;<span style="color:#2b91af">uint32_t</span>&gt; Assemble()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Assembler a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Offsets to labels.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#00f">const</span> <span style="color:#2b91af">int32_t</span> fib = 24;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> <span style="color:#2b91af">int32_t</span> print_loop1 = -24;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> <span style="color:#2b91af">int32_t</span> print_loop2 = -60;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> <span style="color:#2b91af">int32_t</span> printf = 0; <span style="color:#008000">// No value, because we&#39;re going to cheat.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#00f">const</span> <span style="color:#2b91af">int32_t</span> done = 48;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> <span style="color:#2b91af">int32_t</span> fib_loop = -16;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">// main:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s0, 0);                <span style="color:#008000">// li   s0, 0                   ; i = 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s2, 2);                <span style="color:#008000">// li   s2, 2                   ; s2 = 2
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Lui(a0, 1);               <span style="color:#008000">// lui  a0, %hi(format_str)
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Addi(s1, a0, -548);       <span style="color:#008000">// addi s1, a0, %lo(format_str) ; s1 = the address of the printf format string
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s3, 48);               <span style="color:#008000">// li   s3, 48                  ; s3 = 48
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(s4, 1);                <span style="color:#008000">// li   s4, 1                   ; s4 = 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.J(fib);                   <span style="color:#008000">// j    fib                     ; go to fib
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// print_loop:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a0, s1);               <span style="color:#008000">// mv   a0, s1                  ; arg0 = the address of the printf format string
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a1, s0);               <span style="color:#008000">// mv   a1, s0                  ; arg1 = i (arg2 contains current)
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Call(printf);             <span style="color:#008000">// call printf                  ; call printf
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Addi(s0, s0, 1);          <span style="color:#008000">// addi s0, s0, 1               ; i = i + 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Beq(s0, s3, done);        <span style="color:#008000">// beq  s0, s3, done            ; if i == 48 go to done
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// fib:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a2, s0);               <span style="color:#008000">// mv   a2, s0                  ; current = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Bltu(s0, s2, print_loop1);<span style="color:#008000">// bltu s0, s2, print_loop      ; if i &lt; 2 go to print_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(a0, 0);                <span style="color:#008000">// li   a0, 0                   ; previous = 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(a2, 1);                <span style="color:#008000">// li   a2, 1                   ; current = 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a1, s0);               <span style="color:#008000">// mv   a1, s0                  ; n = i
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// fib_loop:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a3, a2);               <span style="color:#008000">// mv   a3, a2                  ; tmp = current
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Addi(a1, a1, -1);         <span style="color:#008000">// addi a1, a1, -1              ; n = n - 1
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Add(a2, a0, a2);          <span style="color:#008000">// add  a2, a0, a2              ; current = current + prev
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Mv(a0, a3);               <span style="color:#008000">// mv   a0, a3                  ; previous = tmp
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Bltu(s4, a1, fib_loop);   <span style="color:#008000">// bltu s4, a1, fib_loop        ; if n &gt; 1 go to fib_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.J(print_loop2);           <span style="color:#008000">// j    print_loop              ; go to print_loop
</span></span></span><span style="display:flex;"><span><span style="color:#008000">// done:
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Li(a0, 0);                <span style="color:#008000">// li   a0, 0                   ; set the return value of main() to 0
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Emit an illegal instruction so that we have something to stop us.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    a.Emit(0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> a.Code();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">auto</span> code = Assemble();
</span></span><span style="display:flex;"><span>    Run(code.data());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s the (shortened) output.</p>
<pre tabindex="0"><code>fib(0) = 0
fib(1) = 1
fib(2) = 1
fib(3) = 2
fib(4) = 3
fib(5) = 5
fib(6) = 8
fib(7) = 13
...
fib(46) = 1836311903
fib(47) = 2971215073
</code></pre><h1 id="and-finally">And finally&hellip;</h1>
<p>Again, this was a long post. The payoff is that we now have beginnings of an emulator for the Owl-2820 CPU. We have also developed a simple assembler so that we can assemble the program that outputs the Fibonacci sequence, and get the expected results when we run it on our emulator.</p>
<p>We can even run it in <a href="https://godbolt.org/z/Y5cKaK85e">Compiler Explorer</a>.</p>
<p>Over the course of the next few posts we&rsquo;ll bring our implementation of the Owl-2820 CPU up to parity with a RISC-V <a href="https://five-embeddev.com/riscv-user-isa-manual/Priv-v1.12/rv32.html">RV32I</a> CPU so that we can use it to do far more than just generating the Fibonacci sequence.</p>
<h1 id="further-reading">Further Reading</h1>
<ul>
<li>Here&rsquo;s the entire program so far on <a href="https://godbolt.org/z/Y5cKaK85e">Compiler Explorer</a></li>
<li>The <a href="https://five-embeddev.com/riscv-user-isa-manual/Priv-v1.12/rv32.html">RV32I Base Integer Instruction Set</a></li>
</ul>
        </div>
        
        <div>
            <ul id="tags">
                
                <li><a href="/tags/vm">vm</a></li>
                
                <li><a href="/tags/owl">owl</a></li>
                
            </ul>
        </div>
        
    </article>
</main>
<aside class="wrapper">
    <div>
        <div>
            <h3>Latest Posts</h3>
        </div>
        <div>
            <ul>
                
                <li><a href="/posts/2024/11/29/lbavm-012/">Let&#39;s build a virtual machine: Part 12 - Dealing with data</a></li>
                
                <li><a href="/posts/2024/10/05/lbavm-011/">Let&#39;s build a virtual machine: Part 11 - Revisiting the instruction handler</a></li>
                
                <li><a href="/posts/2024/09/08/lbavm-010/">Let&#39;s build a virtual machine: Part 10 - Running RISC-V directly</a></li>
                
                <li><a href="/posts/2024/09/01/lbavm-009/">Let&#39;s build a virtual machine: Part 9 - Running compiled C on the Owl-2820 CPU</a></li>
                
                <li><a href="/posts/2024/08/20/lbavm-008/">Let&#39;s build a virtual machine: Part 8 - Using a C compiler to target the Owl-2820 CPU</a></li>
                
            </ul>
        </div>
    </div>
</aside> 
	<footer class="wrapper">
	<p>&copy; 2024 <a href="https://badlydrawnrod.github.io/">My Badly Drawn Self</a></p>
</footer>

</body>
</html>
